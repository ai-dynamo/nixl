mypy.....................................................................[41mFailed[m
[2m- hook id: mypy[m
[2m- exit code: 1[m

tools/perf/utils.py:26: [1m[31merror:[m Incompatible types in assignment (expression has type [m[1m"float"[m, variable has type [m[1m"int"[m)  [m[33m[assignment][m
tools/perf/utils.py:53: [1m[31merror:[m List comprehension has incompatible type List[int]; expected List[str]  [m[33m[misc][m
tools/perf/dist_utils.py:43: [1m[31merror:[m Method must have at least one argument. Did you forget the [m[1m"self"[m argument?  [m[33m[misc][m
tools/perf/dist_utils.py:47: [1m[31merror:[m Method must have at least one argument. Did you forget the [m[1m"self"[m argument?  [m[33m[misc][m
tools/perf/dist_utils.py:104: [1m[31merror:[m Argument 1 to [m[1m"int"[m has incompatible type [m[1m"str | None"[m; expected [m[1m"str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc"[m  [m[33m[arg-type][m
tools/perf/dist_utils.py:105: [1m[31merror:[m Argument 1 to [m[1m"int"[m has incompatible type [m[1m"str | None"[m; expected [m[1m"str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc"[m  [m[33m[arg-type][m
tools/perf/dist_utils.py:121: [1m[31merror:[m Return value expected  [m[33m[return-value][m
tools/perf/custom_traffic_perftest.py:28: [1m[31merror:[m Library stubs not installed for [m[1m"tabulate"[m  [m[33m[import-untyped][m
tools/perf/custom_traffic_perftest.py:28: [34mnote:[m Hint: [m[1m"python3 -m pip install types-tabulate"[m[m
tools/perf/custom_traffic_perftest.py:84: [1m[31merror:[m Need type annotation for [m[1m"dst_bufs_descs"[m (hint: [m[1m"dst_bufs_descs: list[<type>] = ..."[m)  [m[33m[var-annotated][m
tools/perf/custom_traffic_perftest.py:125: [1m[31merror:[m Argument 1 to [m[1m"load_matrix"[m has incompatible type [m[1m"PathLike[Any]"[m; expected [m[1m"str"[m  [m[33m[arg-type][m
tools/perf/custom_traffic_perftest.py:152: [1m[31merror:[m Argument 1 to [m[1m"_share_recv_buf_descs"[m of [m[1m"CTPerftest"[m has incompatible type [m[1m"list[NixlBuffer | None]"[m; expected [m[1m"list[NixlBuffer]"[m  [m[33m[arg-type][m
tools/perf/custom_traffic_perftest.py:168: [1m[31merror:[m Incompatible return value type (got [m[1m"tuple[list[Any], list[NixlBuffer | None], list[NixlBuffer | None]]"[m, expected [m[1m"list[Any]"[m)  [m[33m[return-value][m
tools/perf/custom_traffic_perftest.py:214: [1m[31merror:[m Argument 1 to [m[1m"load_matrix"[m has incompatible type [m[1m"PathLike[Any]"[m; expected [m[1m"str"[m  [m[33m[arg-type][m
tools/perf/custom_traffic_perftest.py:216: [1m[31merror:[m [m[1m"list[list[int]]"[m has no attribute [m[1m"shape"[m  [m[33m[attr-defined][m
tools/perf/custom_traffic_perftest.py:219: [1m[31merror:[m [m[1m"list[list[int]]"[m has no attribute [m[1m"shape"[m  [m[33m[attr-defined][m
tools/perf/custom_traffic_perftest.py:227: [1m[31merror:[m Argument 1 to [m[1m"load_matrix"[m has incompatible type [m[1m"PathLike[Any]"[m; expected [m[1m"str"[m  [m[33m[arg-type][m
tools/perf/custom_traffic_perftest.py:256: [1m[31merror:[m Argument 1 to [m[1m"load_matrix"[m has incompatible type [m[1m"PathLike[Any]"[m; expected [m[1m"str"[m  [m[33m[arg-type][m
tools/perf/multi_custom_traffic_perftest.py:28: [1m[31merror:[m Library stubs not installed for [m[1m"tabulate"[m  [m[33m[import-untyped][m
tools/perf/multi_custom_traffic_perftest.py:69: [1m[31merror:[m Incompatible default for argument [m[1m"tp_done_ts"[m (default has type [m[1m"None"[m, argument has type [m[1m"list[float | None]"[m)  [m[33m[assignment][m
tools/perf/multi_custom_traffic_perftest.py:69: [34mnote:[m PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True[m
tools/perf/multi_custom_traffic_perftest.py:69: [34mnote:[m Use [4mhttps://github.com/hauntsaninja/no_implicit_optional[m to automatically upgrade your codebase[m
tools/perf/multi_custom_traffic_perftest.py:85: [1m[31merror:[m Need type annotation for [m[1m"pending"[m  [m[33m[var-annotated][m
tools/perf/multi_custom_traffic_perftest.py:108: [1m[31merror:[m Incompatible return value type (got [m[1m"tuple[list[float | None], list[list[Any]]]"[m, expected [m[1m"list[float | None]"[m)  [m[33m[return-value][m
tools/perf/multi_custom_traffic_perftest.py:140: [1m[31merror:[m Need type annotation for [m[1m"pending_tp_handles"[m  [m[33m[var-annotated][m
tools/perf/multi_custom_traffic_perftest.py:145: [1m[31merror:[m Incompatible types in assignment (expression has type [m[1m"float | None"[m, variable has type [m[1m"list[None]"[m)  [m[33m[assignment][m
tools/perf/multi_custom_traffic_perftest.py:145: [1m[31merror:[m Incompatible types in assignment (expression has type [m[1m"float | None"[m, variable has type [m[1m"list[list[Any]]"[m)  [m[33m[assignment][m
tools/perf/multi_custom_traffic_perftest.py:148: [1m[31merror:[m Argument [m[1m"tp_done_ts"[m to [m[1m"_wait"[m of [m[1m"MultiCTPerftest"[m has incompatible type [m[1m"list[None]"[m; expected [m[1m"list[float | None]"[m  [m[33m[arg-type][m
tools/perf/multi_custom_traffic_perftest.py:148: [34mnote:[m [m[1m"List"[m is invariant -- see [4mhttps://mypy.readthedocs.io/en/stable/common_issues.html#variance[m[m
tools/perf/multi_custom_traffic_perftest.py:148: [34mnote:[m Consider using [m[1m"Sequence"[m instead, which is covariant[m
tools/perf/multi_custom_traffic_perftest.py:151: [1m[31merror:[m No overload variant of [m[1m"__setitem__"[m of [m[1m"list"[m matches argument types [m[1m"int"[m, [m[1m"float"[m  [m[33m[call-overload][m
tools/perf/multi_custom_traffic_perftest.py:151: [34mnote:[m Possible overload variants:[m
tools/perf/multi_custom_traffic_perftest.py:151: [34mnote:[m     def __setitem__(self, SupportsIndex, None, /) -> None[m
tools/perf/multi_custom_traffic_perftest.py:151: [34mnote:[m     def __setitem__(self, slice[Any, Any, Any], Iterable[None], /) -> None[m
tools/perf/multi_custom_traffic_perftest.py:156: [1m[31merror:[m Incompatible types in assignment (expression has type [m[1m"float"[m, variable has type [m[1m"int"[m)  [m[33m[assignment][m
tools/perf/multi_custom_traffic_perftest.py:160: [1m[31merror:[m [m[1m"_wait"[m of [m[1m"MultiCTPerftest"[m gets multiple values for keyword argument [m[1m"blocking"[m  [m[33m[misc][m
tools/perf/multi_custom_traffic_perftest.py:164: [1m[31merror:[m Unsupported left operand type for - ([m[1m"None"[m)  [m[33m[operator][m
tools/perf/cli.py:20: [1m[31merror:[m Library stubs not installed for [m[1m"yaml"[m  [m[33m[import-untyped][m
tools/perf/cli.py:20: [34mnote:[m Hint: [m[1m"python3 -m pip install types-PyYAML"[m[m
tools/perf/cli.py:20: [34mnote:[m (or run [m[1m"mypy --install-types"[m to install all missing stub packages)[m
tools/perf/cli.py:20: [34mnote:[m See [4mhttps://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports[m[m
[1m[31mFound 30 errors in 5 files (checked 6 source files)[m

isort....................................................................[42mPassed[m
black....................................................................[42mPassed[m
flake8...................................................................[41mFailed[m
[2m- hook id: flake8[m
[2m- exit code: 1[m

[1mtools/perf/custom_traffic_perftest.py[m[36m:[m21[36m:[m1[36m:[m [1m[31mF401[m 'pathlib.Path' imported but unused
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m22[36m:[m1[36m:[m [1m[31mF403[m 'from typing import *' used; unable to detect undefined names
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m52[36m:[m15[36m:[m [1m[31mF405[m 'Literal' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m53[36m:[m14[36m:[m [1m[31mF405[m 'Literal' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m80[36m:[m30[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m82[36m:[m13[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m121[36m:[m21[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m121[36m:[m49[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m197[36m:[m25[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m198[36m:[m25[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/custom_traffic_perftest.py[m[36m:[m224[36m:[m25[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m17[36m:[m1[36m:[m [1m[31mF401[m 'sys' imported but unused
[1mtools/perf/dist_utils.py[m[36m:[m18[36m:[m1[36m:[m [1m[31mF401[m 'time' imported but unused
[1mtools/perf/dist_utils.py[m[36m:[m20[36m:[m1[36m:[m [1m[31mF403[m 'from typing import *' used; unable to detect undefined names
[1mtools/perf/dist_utils.py[m[36m:[m38[36m:[m6[36m:[m [1m[31mF405[m 'final' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m51[36m:[m34[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m51[36m:[m42[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m51[36m:[m47[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m55[36m:[m39[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m55[36m:[m44[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m55[36m:[m53[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m55[36m:[m58[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m86[36m:[m28[36m:[m [1m[31mF405[m 'Tuple' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m135[36m:[m34[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m135[36m:[m42[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m135[36m:[m47[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m148[36m:[m39[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m148[36m:[m44[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m148[36m:[m53[36m:[m [1m[31mF405[m 'List' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m148[36m:[m58[36m:[m [1m[31mF405[m 'Any' may be undefined, or defined from star imports: typing
[1mtools/perf/dist_utils.py[m[36m:[m160[36m:[m9[36m:[m [1m[31mF841[m local variable 'my_rank' is assigned to but never used
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m17[36m:[m1[36m:[m [1m[31mF401[m 'uuid' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m18[36m:[m1[36m:[m [1m[31mF401[m 'dataclasses.dataclass' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m19[36m:[m1[36m:[m [1m[31mF401[m 'os.PathLike' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m20[36m:[m1[36m:[m [1m[31mF401[m 'pathlib.Path' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m21[36m:[m1[36m:[m [1m[31mF403[m 'from typing import *' used; unable to detect undefined names
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m24[36m:[m1[36m:[m [1m[31mF401[m 'torch' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m31[36m:[m1[36m:[m [1m[31mF401[m 'utils.load_matrix' imported but unused
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m57[36m:[m30[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m59[36m:[m13[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m69[36m:[m26[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing
[1mtools/perf/multi_custom_traffic_perftest.py[m[36m:[m70[36m:[m15[36m:[m [1m[31mF405[m 'Optional' may be undefined, or defined from star imports: typing

clang-format.........................................(no files to check)[46;30mSkipped[m
codespell................................................................[41mFailed[m
[2m- hook id: codespell[m
[2m- exit code: 65[m

[33mtools/perf/multi_custom_traffic_perftest.py[0m:[33m126[0m: [31mconnexion[0m ==> [32mconnection[0m

check for case conflicts.................................................[42mPassed[m
check that executables have shebangs.................(no files to check)[46;30mSkipped[m
check for merge conflicts................................................[42mPassed[m
check json...........................................(no files to check)[46;30mSkipped[m
check toml...........................................(no files to check)[46;30mSkipped[m
check yaml...........................................(no files to check)[46;30mSkipped[m
check that scripts with shebangs are executable..........................[42mPassed[m
fix end of files.........................................................[42mPassed[m
mixed line ending........................................................[42mPassed[m
fix requirements.txt.................................(no files to check)[46;30mSkipped[m
trim trailing whitespace.................................................[42mPassed[m
All changes made by hooks:
[1mdiff --git a/tools/perf/cli.py b/tools/perf/cli.py[m
[1mindex 11abcbb..bfb8bdc 100644[m
[1m--- a/tools/perf/cli.py[m
[1m+++ b/tools/perf/cli.py[m
[36m@@ -11,98 +11,120 @@[m
 # distributed under the License is distributed on an "AS IS" BASIS,[m
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 # See the License for the specific language governing permissions and[m
[31m-# limitations under the License.import click[m
[32m+[m[32m# limitations under the License.[m
 [m
[31m-import yaml[m
 import logging[m
 from pathlib import Path[m
[31m-from dist_utils import dist_utils[m
[32m+[m
[32m+[m[32mimport click[m
[32m+[m[32mimport yaml[m
 from custom_traffic_perftest import CTPerftest, TrafficPattern[m
[32m+[m[32mfrom dist_utils import dist_utils[m
 from multi_custom_traffic_perftest import MultiCTPerftest[m
 [m
[32m+[m
 @click.group()[m
[31m-@click.option('--debug/--no-debug', default=False, help="Enable debug logging")[m
[32m+[m[32m@click.option("--debug/--no-debug", default=False, help="Enable debug logging")[m
 def cli(debug):[m
     """NIXL Performance Testing CLI"""[m
     log_level = logging.DEBUG if debug else logging.INFO[m
[31m-    [m
[32m+[m
     # Configure root logger[m
     logging.basicConfig([m
[31m-        level=log_level,[m
[31m-        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'[m
[32m+[m[32m        level=log_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"[m
     )[m
[31m-    [m
[32m+[m
     # Set level for all existing loggers[m
     for logger_name in logging.root.manager.loggerDict:[m
         logger = logging.getLogger(logger_name)[m
         logger.setLevel(log_level)[m
 [m
[32m+[m
 @cli.command()[m
[31m-@click.argument('config_file', type=click.Path(exists=True))[m
[31m-@click.option('--verify-buffers/--no-verify-buffers', default=False, help="Verify buffer contents after transfer")[m
[31m-@click.option('--print-recv-buffers/--no-print-recv-buffers', default=False, help="Print received buffer contents")[m
[32m+[m[32m@click.argument("config_file", type=click.Path(exists=True))[m
[32m+[m[32m@click.option([m
[32m+[m[32m    "--verify-buffers/--no-verify-buffers",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Verify buffer contents after transfer",[m
[32m+[m[32m)[m
[32m+[m[32m@click.option([m
[32m+[m[32m    "--print-recv-buffers/--no-print-recv-buffers",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Print received buffer contents",[m
[32m+[m[32m)[m
 def ct_perftest(config_file, verify_buffers, print_recv_buffers):[m
     """Run custom traffic performance test using patterns defined in YAML config"""[m
[31m-    with open(config_file, 'r') as f:[m
[32m+[m[32m    with open(config_file, "r") as f:[m
         config = yaml.safe_load(f)[m
 [m
[31m-    [m
[31m-    tp_config = config.get('traffic_pattern')[m
[32m+[m[32m    tp_config = config.get("traffic_pattern")[m
     if tp_config is None:[m
         raise ValueError("Config file must contain 'traffic_pattern' key")[m
[31m-    [m
[31m-    required_fields = ['matrix_file', 'shards', 'mem_type', 'xfer_op'][m
[32m+[m
[32m+[m[32m    required_fields = ["matrix_file", "shards", "mem_type", "xfer_op"][m
     missing_fields = [field for field in required_fields if field not in tp_config][m
[31m-        [m
[32m+[m
     if missing_fields:[m
         raise ValueError(f"Traffic pattern missing required fields: {missing_fields}")[m
[31m-    [m
[31m-    iters = config.get('iters', 1)[m
[31m-    warmup_iters = config.get('warmup_iters', 0)[m
[32m+[m
[32m+[m[32m    iters = config.get("iters", 1)[m
[32m+[m[32m    warmup_iters = config.get("warmup_iters", 0)[m
     pattern = TrafficPattern([m
[31m-        matrix_file=Path(tp_config['matrix_file']),[m
[31m-        shards=tp_config['shards'],[m
[31m-        mem_type=tp_config.get('mem_type', 'dram').lower(),[m
[31m-        xfer_op=tp_config.get('xfer_op', 'WRITE').upper(),[m
[32m+[m[32m        matrix_file=Path(tp_config["matrix_file"]),[m
[32m+[m[32m        shards=tp_config["shards"],[m
[32m+[m[32m        mem_type=tp_config.get("mem_type", "dram").lower(),[m
[32m+[m[32m        xfer_op=tp_config.get("xfer_op", "WRITE").upper(),[m
     )[m
[31m-    [m
[32m+[m
     perftest = CTPerftest(pattern, iters=iters, warmup_iters=warmup_iters)[m
     perftest.run(verify_buffers=verify_buffers, print_recv_buffers=print_recv_buffers)[m
     dist_utils.destroy_dist()[m
 [m
[32m+[m
 @cli.command()[m
[31m-@click.argument('config_file', type=click.Path(exists=True))[m
[31m-@click.option('--verify-buffers/--no-verify-buffers', default=False, help="Verify buffer contents after transfer")[m
[31m-@click.option('--print-recv-buffers/--no-print-recv-buffers', default=False, help="Print received buffer contents")[m
[32m+[m[32m@click.argument("config_file", type=click.Path(exists=True))[m
[32m+[m[32m@click.option([m
[32m+[m[32m    "--verify-buffers/--no-verify-buffers",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Verify buffer contents after transfer",[m
[32m+[m[32m)[m
[32m+[m[32m@click.option([m
[32m+[m[32m    "--print-recv-buffers/--no-print-recv-buffers",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Print received buffer contents",[m
[32m+[m[32m)[m
 def multi_ct_perftest(config_file, verify_buffers, print_recv_buffers):[m
     """Run custom traffic performance test using patterns defined in YAML config"""[m
[31m-    with open(config_file, 'r') as f:[m
[32m+[m[32m    with open(config_file, "r") as f:[m
         config = yaml.safe_load(f)[m
[31m-    [m
[31m-    if 'traffic_patterns' not in config:[m
[32m+[m
[32m+[m[32m    if "traffic_patterns" not in config:[m
         raise ValueError("Config file must contain 'traffic_patterns' key")[m
[31m-    [m
[32m+[m
     patterns = [][m
[31m-    for instruction_config in config['traffic_patterns']:[m
[32m+[m[32m    for instruction_config in config["traffic_patterns"]:[m
         tp_config = instruction_config[m
[31m-        required_fields = ['matrix_file', 'shards', 'mem_type', 'xfer_op'][m
[32m+[m[32m        required_fields = ["matrix_file", "shards", "mem_type", "xfer_op"][m
         missing_fields = [field for field in required_fields if field not in tp_config][m
[31m-        [m
[32m+[m
         if missing_fields:[m
[31m-            raise ValueError(f"Traffic pattern missing required fields: {missing_fields}")[m
[31m-        [m
[32m+[m[32m            raise ValueError([m
[32m+[m[32m                f"Traffic pattern missing required fields: {missing_fields}"[m
[32m+[m[32m            )[m
[32m+[m
         pattern = TrafficPattern([m
[31m-            matrix_file=Path(tp_config['matrix_file']),[m
[31m-            shards=tp_config['shards'],[m
[31m-            mem_type=tp_config.get('mem_type', 'dram').lower(),[m
[31m-            xfer_op=tp_config.get('xfer_op', 'WRITE').upper(),[m
[31m-            sleep_after_launch_sec=tp_config.get('sleep_after_launch_sec', 0),[m
[32m+[m[32m            matrix_file=Path(tp_config["matrix_file"]),[m
[32m+[m[32m            shards=tp_config["shards"],[m
[32m+[m[32m            mem_type=tp_config.get("mem_type", "dram").lower(),[m
[32m+[m[32m            xfer_op=tp_config.get("xfer_op", "WRITE").upper(),[m
[32m+[m[32m            sleep_after_launch_sec=tp_config.get("sleep_after_launch_sec", 0),[m
         )[m
         patterns.append(pattern)[m
[31m-    [m
[32m+[m
     perftest = MultiCTPerftest(patterns)[m
     perftest.run(verify_buffers=verify_buffers, print_recv_buffers=print_recv_buffers)[m
     dist_utils.destroy_dist()[m
 [m
[31m-if __name__ == '__main__':[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
     cli()[m
[1mdiff --git a/tools/perf/common.py b/tools/perf/common.py[m
[1mindex a5c28ea..28d3470 100644[m
[1m--- a/tools/perf/common.py[m
[1m+++ b/tools/perf/common.py[m
[36m@@ -12,17 +12,28 @@[m
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 # See the License for the specific language governing permissions and[m
 # limitations under the License.[m
[32m+[m[32mimport logging[m
[32m+[m
 import torch[m
[32m+[m[32mfrom dist_utils import dist_utils[m
[32m+[m
 from nixl._api import nixl_agent[m
[31m-from dist_utils import dist_utils [m
[31m-import logging[m
 [m
 log = logging.getLogger(__name__)[m
 [m
 [m
 class NixlBuffer:[m
     """Can be sharded"""[m
[31m-    def __init__(self, size: int, mem_type: str, nixl_agent: nixl_agent, shards=2, fill_value=0, dtype: torch.dtype = torch.int8):[m
[32m+[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        size: int,[m
[32m+[m[32m        mem_type: str,[m
[32m+[m[32m        nixl_agent: nixl_agent,[m
[32m+[m[32m        shards=2,[m
[32m+[m[32m        fill_value=0,[m
[32m+[m[32m        dtype: torch.dtype = torch.int8,[m
[32m+[m[32m    ):[m
         self.nixl_agent = nixl_agent[m
         if mem_type in ("cuda", "vram"):[m
             device = "cuda"[m
[36m@@ -30,22 +41,35 @@[m [mclass NixlBuffer:[m
             device = "cpu"[m
         else:[m
             raise ValueError(f"Unsupported memory type: {mem_type}")[m
[31m-        [m
[31m-        log.debug(f"[Rank {dist_utils.get_rank()}] Initializing NixlBuffer with size {size}, device {device}, shards {shards}, fill_value {fill_value}")[m
[32m+[m
[32m+[m[32m        log.debug([m
[32m+[m[32m            f"[Rank {dist_utils.get_rank()}] Initializing NixlBuffer with size {size}, device {device}, shards {shards}, fill_value {fill_value}"[m
[32m+[m[32m        )[m
         self.bufs = [][m
         chunk_size = size // shards[m
         self.bufs = [[m
[31m-            torch.full((chunk_size,), fill_value=fill_value, dtype=dtype, device=device) for _ in range(shards)[m
[32m+[m[32m            torch.full((chunk_size,), fill_value=fill_value, dtype=dtype, device=device)[m
[32m+[m[32m            for _ in range(shards)[m
         ][m
         if size % chunk_size != 0:[m
[31m-            self.bufs.append(torch.full((size % chunk_size,), fill_value=fill_value, dtype=dtype, device=device))[m
[32m+[m[32m            self.bufs.append([m
[32m+[m[32m                torch.full([m
[32m+[m[32m                    (size % chunk_size,),[m
[32m+[m[32m                    fill_value=fill_value,[m
[32m+[m[32m                    dtype=dtype,[m
[32m+[m[32m                    device=device,[m
[32m+[m[32m                )[m
[32m+[m[32m            )[m
 [m
         self.reg_descs = nixl_agent.get_reg_descs(self.bufs, mem_type=mem_type)[m
         self.xfer_descs = nixl_agent.get_xfer_descs(self.bufs, mem_type=mem_type)[m
 [m
[31m-        log.debug(f"[Rank {dist_utils.get_rank()}] Registering memory for bufs {self.bufs}")[m
[31m-        assert nixl_agent.register_memory(self.reg_descs) is not None, "Failed to register memory"[m
[31m-    [m
[32m+[m[32m        log.debug([m
[32m+[m[32m            f"[Rank {dist_utils.get_rank()}] Registering memory for bufs {self.bufs}"[m
[32m+[m[32m        )[m
[32m+[m[32m        assert ([m
[32m+[m[32m            nixl_agent.register_memory(self.reg_descs) is not None[m
[32m+[m[32m        ), "Failed to register memory"[m
[32m+[m
     def deregister(self):[m
         self.nixl_agent.deregister_memory(self.reg_descs)[m
[31m-[m
[1mdiff --git a/tools/perf/custom_traffic_perftest.py b/tools/perf/custom_traffic_perftest.py[m
[1mindex 2bc52cc..096d25d 100644[m
[1m--- a/tools/perf/custom_traffic_perftest.py[m
[1m+++ b/tools/perf/custom_traffic_perftest.py[m
[36m@@ -12,38 +12,41 @@[m
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 # See the License for the specific language governing permissions and[m
 # limitations under the License.[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport time[m
[32m+[m[32mimport uuid[m
[32m+[m[32mfrom dataclasses import dataclass[m
 from itertools import chain[m
[31m-from dist_utils import dist_utils[m
[31m-from pathlib import Path[m
[31m-from utils import load_matrix[m
 from os import PathLike[m
[31m-from common import NixlBuffer[m
[32m+[m[32mfrom pathlib import Path[m
 from typing import *[m
[31m-import logging[m
[31m-from dataclasses import dataclass[m
[31m-import uuid[m
[31m-import time[m
[32m+[m
 import numpy as np[m
 import torch[m
[32m+[m[32mfrom common import NixlBuffer[m
[32m+[m[32mfrom dist_utils import dist_utils[m
 from tabulate import tabulate[m
 [m
 from nixl._api import nixl_agent[m
[32m+[m[32mfrom utils import load_matrix[m
 [m
 log = logging.getLogger(__name__)[m
 [m
[32m+[m
 @dataclass[m
 class TrafficPattern:[m
     """Represents a communication pattern between distributed processes.[m
[31m-    [m
[32m+[m
     Attributes:[m
         matrix_file: Path to the file containing the communication matrix[m
         shards: Number of shards for distributed processing[m
         mem_type: Type of memory to use[m
[31m-        xfer_op: Transfer operation type [m
[32m+[m[32m        xfer_op: Transfer operation type[m
         dtype: PyTorch data type for the buffers[m
         sleep_sec: Number of seconds to sleep after finish[m
         id: Unique identifier for this traffic pattern[m
     """[m
[32m+[m
     matrix_file: PathLike[m
     shards: int[m
     mem_type: Literal["cuda", "vram", "cpu", "dram"][m
[36m@@ -53,8 +56,11 @@[m [mclass TrafficPattern:[m
 [m
     id: str = str(uuid.uuid4())[m
 [m
[32m+[m
 class CTPerftest:[m
[31m-    def __init__(self, traffic_pattern: TrafficPattern, iters: int = 1, warmup_iters: int = 0):[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self, traffic_pattern: TrafficPattern, iters: int = 1, warmup_iters: int = 0[m
[32m+[m[32m    ):[m
         """[m
         Args:[m
             traffic_pattern: The communication pattern to test[m
[36m@@ -71,10 +77,13 @@[m [mclass CTPerftest:[m
         self.nixl_agent = nixl_agent(f"{self.my_rank}")[m
         assert "UCX" in self.nixl_agent.get_plugin_list(), "UCX plugin is not loaded"[m
 [m
[31m-[m
[31m-        self.send_bufs: list[Optional[NixlBuffer]] = [] # [i]=None if no send to rank i[m
[31m-        self.recv_bufs: list[Optional[NixlBuffer]] = [] # [i]=None if no recv from rank i  [m
[31m-        self.dst_bufs_descs = [] # [i]=None if no recv from rank i else descriptor of the dst buffer[m
[32m+[m[32m        self.send_bufs: list[Optional[NixlBuffer]] = []  # [i]=None if no send to rank i[m
[32m+[m[32m        self.recv_bufs: list[[m
[32m+[m[32m            Optional[NixlBuffer][m
[32m+[m[32m        ] = []  # [i]=None if no recv from rank i[m
[32m+[m[32m        self.dst_bufs_descs = ([m
[32m+[m[32m            [][m
[32m+[m[32m        )  # [i]=None if no recv from rank i else descriptor of the dst buffer[m
 [m
     def _share_md(self) -> None:[m
         """Share agent metadata between all ranks. (Need to be run after registering buffers)"""[m
[36m@@ -84,25 +93,32 @@[m [mclass CTPerftest:[m
             if other_rank == self.my_rank:[m
                 continue[m
             self.nixl_agent.add_remote_agent(metadata)[m
[31m-        [m
[32m+[m
     def _share_recv_buf_descs(self, my_recv_bufs: list[NixlBuffer]) -> list:[m
         """Share receive buffer descriptors between all ranks, in alltoall style.[m
[31m-        [m
[32m+[m
         Args:[m
             my_recv_bufs: List of receive buffers for current rank[m
[31m-            [m
[32m+[m
         Returns:[m
             List of buffer descriptors from all ranks[m
         """[m
[31m-        my_recv_bufs_descs = [buf.xfer_descs if buf is not None else None for buf in my_recv_bufs][m
[31m-        my_recv_bufs_serdes = [self.nixl_agent.get_serialized_descs(des) for des in my_recv_bufs_descs][m
[32m+[m[32m        my_recv_bufs_descs = [[m
[32m+[m[32m            buf.xfer_descs if buf is not None else None for buf in my_recv_bufs[m
[32m+[m[32m        ][m
[32m+[m[32m        my_recv_bufs_serdes = [[m
[32m+[m[32m            self.nixl_agent.get_serialized_descs(des) for des in my_recv_bufs_descs[m
[32m+[m[32m        ][m
 [m
         dst_bufs_serdes = dist_utils.alltoall_obj(my_recv_bufs_serdes)[m
[31m-        dst_bufs_descs = [self.nixl_agent.deserialize_descs(serdes) for serdes in dst_bufs_serdes][m
[32m+[m[32m        dst_bufs_descs = [[m
[32m+[m[32m            self.nixl_agent.deserialize_descs(serdes) for serdes in dst_bufs_serdes[m
[32m+[m[32m        ][m
         return dst_bufs_descs[m
 [m
[31m-    def _init_buffers(self, tp: TrafficPattern) -> tuple[list[Optional[NixlBuffer]], list[Optional[NixlBuffer]]]:[m
[31m-    [m
[32m+[m[32m    def _init_buffers([m
[32m+[m[32m        self, tp: TrafficPattern[m
[32m+[m[32m    ) -> tuple[list[Optional[NixlBuffer]], list[Optional[NixlBuffer]]]:[m
         send_bufs = [][m
         recv_bufs = [][m
         for other_rank in range(self.world_size):[m
[36m@@ -111,17 +127,27 @@[m [mclass CTPerftest:[m
             recv_size = matrix[other_rank][self.my_rank][m
             send_buf = recv_buf = None[m
             if send_size > 0:[m
[31m-                send_buf = NixlBuffer(send_size, mem_type=tp.mem_type, nixl_agent=self.nixl_agent, fill_value=self.my_rank, dtype=tp.dtype)[m
[32m+[m[32m                send_buf = NixlBuffer([m
[32m+[m[32m                    send_size,[m
[32m+[m[32m                    mem_type=tp.mem_type,[m
[32m+[m[32m                    nixl_agent=self.nixl_agent,[m
[32m+[m[32m                    fill_value=self.my_rank,[m
[32m+[m[32m                    dtype=tp.dtype,[m
[32m+[m[32m                )[m
             if recv_size > 0:[m
[31m-                recv_buf = NixlBuffer(recv_size, mem_type=tp.mem_type, nixl_agent=self.nixl_agent, dtype=tp.dtype)[m
[32m+[m[32m                recv_buf = NixlBuffer([m
[32m+[m[32m                    recv_size,[m
[32m+[m[32m                    mem_type=tp.mem_type,[m
[32m+[m[32m                    nixl_agent=self.nixl_agent,[m
[32m+[m[32m                    dtype=tp.dtype,[m
[32m+[m[32m                )[m
             send_bufs.append(send_buf)[m
             recv_bufs.append(recv_buf)[m
[31m-        [m
[32m+[m
         self._share_md()[m
         return send_bufs, recv_bufs[m
 [m
     def _prepare_tp(self, tp: TrafficPattern) -> list:[m
[31m-[m
         send_bufs, recv_bufs = self._init_buffers(tp)[m
         dst_bufs_descs = self._share_recv_buf_descs(recv_bufs)[m
 [m
[36m@@ -135,12 +161,12 @@[m [mclass CTPerftest:[m
                 buf.xfer_descs,[m
                 dst_bufs_descs[other],[m
                 f"{other}",[m
[31m-                f"{tp.id}_{self.my_rank}_{other}"[m
[32m+[m[32m                f"{tp.id}_{self.my_rank}_{other}",[m
             )[m
             handles.append(handle)[m
[31m-        [m
[32m+[m
         return handles, send_bufs, recv_bufs[m
[31m-    [m
[32m+[m
     def _run_tp(self, handles: list):[m
         pending = [][m
         for handle in handles:[m
[36m@@ -164,33 +190,47 @@[m [mclass CTPerftest:[m
             if not pending:[m
                 break[m
             handles = pending[m
[31m-    [m
[31m-    def _destroy(self, handles: list, send_bufs: list[Optional[NixlBuffer]], recv_bufs: list[Optional[NixlBuffer]]):[m
[32m+[m
[32m+[m[32m    def _destroy([m
[32m+[m[32m        self,[m
[32m+[m[32m        handles: list,[m
[32m+[m[32m        send_bufs: list[Optional[NixlBuffer]],[m
[32m+[m[32m        recv_bufs: list[Optional[NixlBuffer]],[m
[32m+[m[32m    ):[m
         for handle in handles:[m
             self.nixl_agent.release_xfer_handle(handle)[m
[31m-        [m
[32m+[m
         for other_rank in range(self.world_size):[m
             if other_rank == self.my_rank:[m
                 continue[m
             self.nixl_agent.remove_remote_agent(f"{other_rank}")[m
[31m-        [m
[32m+[m
         for buf in chain(send_bufs, recv_bufs):[m
             if buf is None:[m
                 continue[m
             buf.deregister()[m
[31m-        [m
[32m+[m
     def _check_tp_config(self, tp: TrafficPattern):[m
         matrix = load_matrix(tp.matrix_file)[m
         # Matrix size should be world * world[m
[31m-        assert matrix.shape == (self.world_size, self.world_size), f"Matrix size is not the same as world size, got {matrix.shape}, world_size={self.world_size}"[m
[31m-[m
[31m-    def _verify_tp(self, tp: TrafficPattern, recv_bufs: list[Optional[NixlBuffer]], print_recv_buffers: bool = False):[m
[32m+[m[32m        assert matrix.shape == ([m
[32m+[m[32m            self.world_size,[m
[32m+[m[32m            self.world_size,[m
[32m+[m[32m        ), f"Matrix size is not the same as world size, got {matrix.shape}, world_size={self.world_size}"[m
[32m+[m
[32m+[m[32m    def _verify_tp([m
[32m+[m[32m        self,[m
[32m+[m[32m        tp: TrafficPattern,[m
[32m+[m[32m        recv_bufs: list[Optional[NixlBuffer]],[m
[32m+[m[32m        print_recv_buffers: bool = False,[m
[32m+[m[32m    ):[m
         matrix = load_matrix(tp.matrix_file)[m
         for r, recv_buf in enumerate(recv_bufs):[m
[31m-[m
             if recv_buf is None:[m
                 if matrix[r][self.my_rank] > 0:[m
[31m-                    log.error(f"Rank {self.my_rank} expected {matrix[r][self.my_rank]} bytes from rank {r}, but got 0")[m
[32m+[m[32m                    log.error([m
[32m+[m[32m                        f"Rank {self.my_rank} expected {matrix[r][self.my_rank]} bytes from rank {r}, but got 0"[m
[32m+[m[32m                    )[m
                     raise RuntimeError("Buffer verification failed")[m
                 continue[m
 [m
[36m@@ -204,21 +244,27 @@[m [mclass CTPerftest:[m
             # and its size has to be the same as matrix[r][my_rank][m
             full_recv_buf = torch.cat([b for b in recv_buf.bufs])[m
             expected = torch.full_like(full_recv_buf, r)[m
[31m-            assert torch.all(full_recv_buf == expected), f"Vector not equal to {r}, got {full_recv_buf}"[m
[31m-            assert full_recv_buf.size(0) == matrix[r][self.my_rank], f"Size of vector {r} is not the same as matrix[r][{self.my_rank}], got {full_recv_buf.size(0)}"[m
[32m+[m[32m            assert torch.all([m
[32m+[m[32m                full_recv_buf == expected[m
[32m+[m[32m            ), f"Vector not equal to {r}, got {full_recv_buf}"[m
[32m+[m[32m            assert ([m
[32m+[m[32m                full_recv_buf.size(0) == matrix[r][self.my_rank][m
[32m+[m[32m            ), f"Size of vector {r} is not the same as matrix[r][{self.my_rank}], got {full_recv_buf.size(0)}"[m
 [m
     def _get_tp_total_size(self, tp: TrafficPattern) -> int:[m
         """Return total size of matrix in bytes"""[m
         matrix = load_matrix(tp.matrix_file)[m
[31m-        return np.sum(matrix, axis=(0,1)) * tp.dtype.itemsize[m
[32m+[m[32m        return np.sum(matrix, axis=(0, 1)) * tp.dtype.itemsize[m
 [m
[31m-    def run(self, verify_buffers: bool = False, print_recv_buffers: bool = False) -> float:[m
[32m+[m[32m    def run([m
[32m+[m[32m        self, verify_buffers: bool = False, print_recv_buffers: bool = False[m
[32m+[m[32m    ) -> float:[m
         """Execute the performance test.[m
[31m-        [m
[32m+[m
         Args:[m
             verify_buffers: Whether to verify buffer contents after transfer[m
             print_recv_buffers: Whether to print receive buffer contents[m
[31m-            [m
[32m+[m
         Returns:[m
             Total execution time in seconds[m
         """[m
[36m@@ -236,18 +282,32 @@[m [mclass CTPerftest:[m
 [m
         # Metrics report[m
         start_times = dist_utils.allgather_obj(start)[m
[31m-        end_times = dist_utils.allgather_obj(end)   [m
[32m+[m[32m        end_times = dist_utils.allgather_obj(end)[m
 [m
         global_time = max(end_times) - min(start_times)[m
         avg_time_per_iter_sec = global_time / self.iters[m
 [m
[31m-        total_size_gb = self._get_tp_total_size(self.traffic_pattern) / 1E9[m
[32m+[m[32m        total_size_gb = self._get_tp_total_size(self.traffic_pattern) / 1e9[m
         alg_bw_gbps = total_size_gb / avg_time_per_iter_sec / self.world_size[m
 [m
         # Print metrics as a table[m
         if self.my_rank == 0:[m
[31m-            headers = ["Iters", "Total time (s)", "Avg Time/iter (s)", "Total size (GB)", "Alg BW (GB/s)"][m
[31m-            data = [[self.iters, global_time, avg_time_per_iter_sec, total_size_gb, alg_bw_gbps]][m
[32m+[m[32m            headers = [[m
[32m+[m[32m                "Iters",[m
[32m+[m[32m                "Total time (s)",[m
[32m+[m[32m                "Avg Time/iter (s)",[m
[32m+[m[32m                "Total size (GB)",[m
[32m+[m[32m                "Alg BW (GB/s)",[m
[32m+[m[32m            ][m
[32m+[m[32m            data = [[m
[32m+[m[32m                [[m
[32m+[m[32m                    self.iters,[m
[32m+[m[32m                    global_time,[m
[32m+[m[32m                    avg_time_per_iter_sec,[m
[32m+[m[32m                    total_size_gb,[m
[32m+[m[32m                    alg_bw_gbps,[m
[32m+[m[32m                ][m
[32m+[m[32m            ][m
             log.info("\n" + tabulate(data, headers=headers, floatfmt=".6f"))[m
 [m
         if verify_buffers:[m
[36m@@ -256,4 +316,3 @@[m [mclass CTPerftest:[m
         self._destroy(handles, send_bufs, recv_bufs)[m
 [m
         return end - start[m
[31m-    [m
[1mdiff --git a/tools/perf/dist_utils.py b/tools/perf/dist_utils.py[m
[1mindex 0f04925..b928d9d 100644[m
[1m--- a/tools/perf/dist_utils.py[m
[1m+++ b/tools/perf/dist_utils.py[m
[36m@@ -12,18 +12,19 @@[m
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 # See the License for the specific language governing permissions and[m
 # limitations under the License.[m
[31m-import time[m
[31m-import sys[m
[31m-import os [m
[31m-from typing import *[m
 import logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport time[m
 from abc import ABC, abstractmethod[m
[32m+[m[32mfrom typing import *[m
 [m
 from nixl._api import nixl_agent[m
 [m
 try:[m
     import torch[m
     import torch.distributed as dist[m
[32m+[m
     has_torch = True[m
 except ImportError:[m
     has_torch = False[m
[36m@@ -62,7 +63,7 @@[m [mclass _DistUtils(ABC):[m
     def get_world_size(self) -> int:[m
         pass[m
 [m
[31m-    def share_world_metadata(self, nixl_agent: 'nixl_agent') -> None:[m
[32m+[m[32m    def share_world_metadata(self, nixl_agent: "nixl_agent") -> None:[m
         my_rank = self.get_rank()[m
 [m
         log.debug(f"[Rank {my_rank}] Sharing agent metadata with other ranks")[m
[36m@@ -76,7 +77,6 @@[m [mclass _DistUtils(ABC):[m
 [m
 [m
 class _TorchDistUtils(_DistUtils):[m
[31m-[m
     def get_rank(self) -> int:[m
         return dist.get_rank()[m
 [m
[36m@@ -85,10 +85,10 @@[m [mclass _TorchDistUtils(_DistUtils):[m
 [m
     def init_dist(self) -> Tuple[int, int]:[m
         """Init torch distributed module[m
[31m-        [m
[32m+[m
         Returns:[m
             Tuple[int, int]: Tuple of (rank, world_size)[m
[31m-            [m
[32m+[m
         Raises:[m
             ValueError: If rank and world size cannot be determined[m
             RuntimeError: If CUDA is not available[m
[36m@@ -107,16 +107,18 @@[m [mclass _TorchDistUtils(_DistUtils):[m
             raise ValueError("Could not parse rank and world size")[m
 [m
         dist.init_process_group([m
[31m-            backend='nccl',[m
[32m+[m[32m            backend="nccl",[m
             rank=rank,[m
             world_size=world_size,[m
         )[m
 [m
         rank = dist.get_rank()[m
 [m
[31m-        if torch.cuda.device_count() == 0: [m
[31m-            print("No CUDA device have been detected, maybe you forgot to add --gpus-per-node option in srun?")[m
[31m-            return [m
[32m+[m[32m        if torch.cuda.device_count() == 0:[m
[32m+[m[32m            print([m
[32m+[m[32m                "No CUDA device have been detected, maybe you forgot to add --gpus-per-node option in srun?"[m
[32m+[m[32m            )[m
[32m+[m[32m            return[m
 [m
         device = rank % torch.cuda.device_count()[m
         torch.cuda.set_device(device)[m
[36m@@ -129,13 +131,13 @@[m [mclass _TorchDistUtils(_DistUtils):[m
         """Cleanup distributed process group"""[m
         if dist.is_initialized():[m
             dist.destroy_process_group()[m
[31m-    [m
[32m+[m
     def allgather_obj(self, obj: Any) -> List[Any]:[m
         """Allgather arbitrary object on world[m
[31m-        [m
[32m+[m
         Args:[m
             obj: Object to gather from all ranks[m
[31m-            [m
[32m+[m
         Returns:[m
             List[Any]: List of gathered objects, one from each rank[m
         """[m
[36m@@ -145,33 +147,36 @@[m [mclass _TorchDistUtils(_DistUtils):[m
 [m
     def alltoall_obj(self, send_objs: List[Any]) -> List[Any]:[m
         """All-to-all communication of arbitrary objects on world[m
[31m-        [m
[32m+[m
         Args:[m
             send_objs: List of objects to send, length must equal world_size[m
[31m-            [m
[32m+[m
         Returns:[m
             List[Any]: List of received objects[m
[31m-            [m
[32m+[m
         Raises:[m
             AssertionError: If length of send_objs doesn't match world_size[m
         """[m
         my_rank = self.get_rank()[m
         world_size = self.get_world_size()[m
 [m
[31m-        assert len(send_objs) == world_size, f"Invalid number of objects {len(send_objs)}, expected {world_size}"[m
[32m+[m[32m        assert ([m
[32m+[m[32m            len(send_objs) == world_size[m
[32m+[m[32m        ), f"Invalid number of objects {len(send_objs)}, expected {world_size}"[m
 [m
         recv_objs = [None for _ in range(len(send_objs))][m
 [m
         for other_rank in range(world_size):[m
             output = [None][m
             dist.scatter_object_list([m
[31m-                scatter_object_output_list=output, [m
[31m-                scatter_object_input_list=send_objs, [m
[31m-                src=other_rank[m
[32m+[m[32m                scatter_object_output_list=output,[m
[32m+[m[32m                scatter_object_input_list=send_objs,[m
[32m+[m[32m                src=other_rank,[m
             )[m
             recv_objs[other_rank] = output[0][m
 [m
         return recv_objs[m
 [m
[32m+[m
 dist_utils = _TorchDistUtils()[m
[31m-dist_utils.init_dist()[m
\ No newline at end of file[m
[32m+[m[32mdist_utils.init_dist()[m
[1mdiff --git a/tools/perf/multi_custom_traffic_perftest.py b/tools/perf/multi_custom_traffic_perftest.py[m
[1mindex 4edd1ce..c12da3a 100644[m
[1m--- a/tools/perf/multi_custom_traffic_perftest.py[m
[1m+++ b/tools/perf/multi_custom_traffic_perftest.py[m
[36m@@ -12,36 +12,37 @@[m
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 # See the License for the specific language governing permissions and[m
 # limitations under the License.[m
[31m-from dist_utils import dist_utils[m
[31m-from tabulate import tabulate[m
[31m-from pathlib import Path[m
[31m-from utils import load_matrix[m
[31m-from os import PathLike[m
[31m-from common import NixlBuffer[m
[31m-from typing import *[m
 import logging[m
[31m-from dataclasses import dataclass[m
[31m-import uuid[m
 import time[m
[32m+[m[32mimport uuid[m
[32m+[m[32mfrom dataclasses import dataclass[m
[32m+[m[32mfrom os import PathLike[m
[32m+[m[32mfrom pathlib import Path[m
[32m+[m[32mfrom typing import *[m
[32m+[m
 import numpy as np[m
 import torch[m
[32m+[m[32mfrom common import NixlBuffer[m
[32m+[m[32mfrom custom_traffic_perftest import CTPerftest, TrafficPattern[m
[32m+[m[32mfrom dist_utils import dist_utils[m
[32m+[m[32mfrom tabulate import tabulate[m
 [m
 from nixl._api import nixl_agent[m
[31m-[m
[31m-from custom_traffic_perftest import CTPerftest, TrafficPattern[m
[32m+[m[32mfrom utils import load_matrix[m
 [m
 log = logging.getLogger(__name__)[m
 [m
[32m+[m
 class MultiCTPerftest(CTPerftest):[m
     """Extends CTPerftest to handle multiple traffic patterns simultaneously.[m
     The patterns are executed in parallel, and the results are aggregated.[m
[31m-    [m
[32m+[m
     Allows testing multiple communication patterns in parallel between distributed processes.[m
     """[m
[31m-    [m
[32m+[m
     def __init__(self, traffic_patterns: list[TrafficPattern]) -> None:[m
         """Initialize multi-pattern performance test.[m
[31m-        [m
[32m+[m
         Args:[m
             traffic_patterns: List of traffic patterns to test simultaneously[m
         """[m
[36m@@ -53,18 +54,27 @@[m [mclass MultiCTPerftest(CTPerftest):[m
         self.nixl_agent = nixl_agent(f"{self.my_rank}")[m
         assert "UCX" in self.nixl_agent.get_plugin_list(), "UCX plugin is not loaded"[m
 [m
[31m-        self.send_bufs: list[Optional[NixlBuffer]] = [] # [i]=None if no send to rank i[m
[31m-        self.recv_bufs: list[Optional[NixlBuffer]] = [] # [i]=None if no recv from rank i[m
[31m-        self.dst_bufs_descs = [] # [i]=None if no recv from rank i else descriptor of the dst buffer[m
[31m-[m
[31m-    def _wait(self, tp_handles: list[list], blocking=True, tp_done_ts: list[Optional[float]] = None) -> list[Optional[float]]:[m
[32m+[m[32m        self.send_bufs: list[Optional[NixlBuffer]] = []  # [i]=None if no send to rank i[m
[32m+[m[32m        self.recv_bufs: list[[m
[32m+[m[32m            Optional[NixlBuffer][m
[32m+[m[32m        ] = []  # [i]=None if no recv from rank i[m
[32m+[m[32m        self.dst_bufs_descs = ([m
[32m+[m[32m            [][m
[32m+[m[32m        )  # [i]=None if no recv from rank i else descriptor of the dst buffer[m
[32m+[m
[32m+[m[32m    def _wait([m
[32m+[m[32m        self,[m
[32m+[m[32m        tp_handles: list[list],[m
[32m+[m[32m        blocking=True,[m
[32m+[m[32m        tp_done_ts: list[Optional[float]] = None,[m
[32m+[m[32m    ) -> list[Optional[float]]:[m
         """Wait for all transfers to complete and record completion times.[m
         Can be non blocking[m
[31m-        [m
[32m+[m
         Args:[m
             tp_handles: List of transfer handles for each traffic pattern[m
             tp_done_ts: List of completion timestamps for each traffic pattern to fill, if not provided, will be created and filled[m
[31m-            [m
[32m+[m
         Returns:[m
             List of completion timestamps for each traffic pattern, pending handles (in format of tp_handles)[m
             if any(pending) is True, then the wait is not complete[m
[36m@@ -82,6 +92,7 @@[m [mclass MultiCTPerftest(CTPerftest):[m
                     except Exception as e:[m
                         print(f"Error checking xfer state for handle {handle}: {e}")[m
                         import sys[m
[32m+[m
                         sys.exit(1)[m
                     assert state != "ERR", "Transfer got to Error state."[m
                     if state != "DONE":[m
[36m@@ -93,19 +104,21 @@[m [mclass MultiCTPerftest(CTPerftest):[m
 [m
             if not blocking or not any(tp_handles):[m
                 break[m
[31m-        [m
[32m+[m
         return tp_done_ts, pending[m
 [m
[31m-    def run(self, verify_buffers: bool = False, print_recv_buffers: bool = False) -> float:[m
[32m+[m[32m    def run([m
[32m+[m[32m        self, verify_buffers: bool = False, print_recv_buffers: bool = False[m
[32m+[m[32m    ) -> float:[m
         """Execute all traffic patterns in parallel.[m
[31m-        [m
[32m+[m
         Args:[m
             verify_buffers: Whether to verify buffer contents after transfer[m
             print_recv_buffers: Whether to print receive buffer contents[m
[31m-            [m
[32m+[m
         Returns:[m
             Total execution time in seconds[m
[31m-        [m
[32m+[m
         This method initializes and executes multiple traffic patterns simultaneously,[m
         measures their performance, and optionally verifies the results.[m
         """[m
[36m@@ -118,7 +131,6 @@[m [mclass MultiCTPerftest(CTPerftest):[m
             handles, send_bufs, recv_bufs = self._prepare_tp(tp)[m
             tp_bufs.append((send_bufs, recv_bufs))[m
             tp_handles.append(handles)[m
[31m-        [m
 [m
         start_ts_by_tp = [None for _ in tp_handles][m
         end_ts_by_tp = [None for _ in tp_handles][m
[36m@@ -127,14 +139,14 @@[m [mclass MultiCTPerftest(CTPerftest):[m
         next_ts = 0[m
         pending_tp_handles = [[] for _ in tp_handles][m
 [m
[31m-        while tp_ix < len(tp_handles): [m
[32m+[m[32m        while tp_ix < len(tp_handles):[m
             if time.time() < next_ts:[m
                 # Run wait in non-blocking mode to avoid blocking the main thread[m
                 end_ts_by_tp, pending_tp_handles = self._wait([m
[31m-                    pending_tp_handles, [m
[31m-                    blocking=False, [m
[31m-                    tp_done_ts=end_ts_by_tp, [m
[31m-                    )[m
[32m+[m[32m                    pending_tp_handles,[m
[32m+[m[32m                    blocking=False,[m
[32m+[m[32m                    tp_done_ts=end_ts_by_tp,[m
[32m+[m[32m                )[m
                 continue[m
             start_ts_by_tp[tp_ix] = time.perf_counter()[m
             pending_tp_handles[tp_ix] = self._run_tp(tp_handles[tp_ix])[m
[36m@@ -142,15 +154,21 @@[m [mclass MultiCTPerftest(CTPerftest):[m
 [m
             if sleep > 0:[m
                 next_ts = time.time() + sleep[m
[31m-                [m
[32m+[m
             tp_ix += 1[m
 [m
         self._wait(tp_handles, end_ts_by_tp, blocking=True)[m
         end = time.time()[m
 [m
[31m-        tp_times_sec = [end_ts_by_tp[i] - start_ts_by_tp[i] for i in range(len(tp_handles))][m
[31m-        tp_sizes_gb = [self._get_tp_total_size(tp) / 1E9 for tp in self.traffic_patterns][m
[31m-        tp_bandwidths_gbps = [tp_sizes_gb[i] / tp_times_sec[i] for i in range(len(tp_handles))][m
[32m+[m[32m        tp_times_sec = [[m
[32m+[m[32m            end_ts_by_tp[i] - start_ts_by_tp[i] for i in range(len(tp_handles))[m
[32m+[m[32m        ][m
[32m+[m[32m        tp_sizes_gb = [[m
[32m+[m[32m            self._get_tp_total_size(tp) / 1e9 for tp in self.traffic_patterns[m
[32m+[m[32m        ][m
[32m+[m[32m        tp_bandwidths_gbps = [[m
[32m+[m[32m            tp_sizes_gb[i] / tp_times_sec[i] for i in range(len(tp_handles))[m
[32m+[m[32m        ][m
         avg_tp_bw = np.mean(tp_bandwidths_gbps)[m
 [m
         # Metrics report[m
[36m@@ -161,7 +179,7 @@[m [mclass MultiCTPerftest(CTPerftest):[m
         # This is the total time taken by all ranks to run all traffic patterns[m
         global_total_time = max(end_times) - min(start_times)[m
         global_avg_tp_bw = np.mean(avg_tp_bws)[m
[31m-    [m
[32m+[m
         if self.my_rank == 0:[m
             headers = ["Total time (s)", "Avg pattern BW (GB/s)"][m
             data = [[global_total_time, global_avg_tp_bw]][m
[1mdiff --git a/tools/perf/utils.py b/tools/perf/utils.py[m
[1mindex 82a8d10..a9018c3 100644[m
[1m--- a/tools/perf/utils.py[m
[1m+++ b/tools/perf/utils.py[m
[36m@@ -13,25 +13,26 @@[m
 # See the License for the specific language governing permissions and[m
 # limitations under the License.[m
 import logging[m
[32m+[m
 import numpy as np[m
 [m
 log = logging.getLogger(__name__)[m
 [m
[32m+[m
 def format_size(nbytes: int, precision=2) -> str:[m
[31m-    units = ['B', 'K', 'M', 'G'][m
[32m+[m[32m    units = ["B", "K", "M", "G"][m
     units_ix = 0[m
[31m-    while nbytes/1024 >= 1 and units_ix < len(units)-1:[m
[32m+[m[32m    while nbytes / 1024 >= 1 and units_ix < len(units) - 1:[m
         nbytes /= 1024[m
         units_ix += 1[m
[31m-    [m
[32m+[m
     nbytes = round(nbytes, precision)[m
     return f"{nbytes:g}{units[units_ix]}"[m
[31m-    [m
[32m+[m
[32m+[m
 def parse_size(nbytes: str) -> int:[m
     """Convert formatted string with unit to bytes"""[m
[31m-    options = {'g': 1024*1024*1024,[m
[31m-                'm': 1024*1024,[m
[31m-                'k': 1024}[m
[32m+[m[32m    options = {"g": 1024 * 1024 * 1024, "m": 1024 * 1024, "k": 1024}[m
     unit = 1[m
     key = nbytes[-1].lower()[m
     if key in options:[m
[36m@@ -39,17 +40,18 @@[m [mdef parse_size(nbytes: str) -> int:[m
         value = int(nbytes[:-1])[m
     else:[m
         value = int(nbytes)[m
[31m-    count = unit * value [m
[32m+[m[32m    count = unit * value[m
     return count[m
 [m
[32m+[m
 def load_matrix(matrix_file: str) -> list[list[int]]:[m
     # Cell i,j of the matrix is the size of the message to send from process i to process j[m
     matrix = [][m
[31m-    with open(matrix_file, 'r') as f:[m
[32m+[m[32m    with open(matrix_file, "r") as f:[m
         for line in f:[m
             row = line.strip().split()[m
             row = [parse_size(x) for x in row][m
             matrix.append(row)[m
     mat = np.array(matrix)[m
 [m
[31m-    return mat[m
\ No newline at end of file[m
[32m+[m[32m    return mat[m
